@app.route('/get_user_track')
def getTracks():
    try:
        token_info = helper.get_user_token(TOKEN_INFO)
    except:
        print("user not logged in")
        redirect(url_for("login", _external = False))
    sp = spotipy.Spotify(auth=token_info['access_token'])
    
    songs = []
    artists = []
    artist_name = []
    popularity = []
    Length, Danceability, Acousticness, Energy, Instrumentalness, Liveness, Valence, Loudness, Speechiness, Tempo = ([] for i in range(10))
    for offsetamount in range(6):
        saved_tracks = sp.current_user_saved_tracks(limit=50, offset=offsetamount*50)['items']
    
        for i in range(len(saved_tracks)):
            songs.append(saved_tracks[i]['track']['name'])
            artists.append(saved_tracks[i]['track']['artists'][0]['name'])
            
            popularity.append(saved_tracks[i]['track']['popularity'])
        #get audio feature
        feature = []
        
        for i in range(len(saved_tracks)):
            # Make the API request
            test_track = saved_tracks[i]['track']['id']
            #print(test_track)
            test_feature = None
            delay = 1
            time.sleep(delay)
            while test_feature is None:
                try:
                    test_feature = sp.audio_features(test_track)
                except spotipy.exceptions.SpotifyException as e:
                    
                    if e.http_status == 429:
                        
                        # Rate limit exceeded, implement exponential backoff
                        delay = 2 * delay  # Increase delay exponentially
                        print(f"Rate limit exceeded. Retrying in {delay} seconds...")
                        
                        time.sleep(delay)
                    else:
                        # Other error occurred, handle it accordingly
                        raise e

            for feature in range(len(test_feature)):
                Length.append((int(test_feature[feature]['duration_ms']) / 1000)/60)
                Danceability.append(test_feature[feature]['danceability'])
                Acousticness.append(test_feature[feature]['acousticness'])
                Energy.append(test_feature[feature]['energy'])
                Instrumentalness.append(test_feature[feature]['instrumentalness'])
                Liveness.append(test_feature[feature]['liveness'])
                Valence.append(test_feature[feature]['valence'])
                Loudness.append(test_feature[feature]['loudness'])
                Speechiness.append(test_feature[feature]['speechiness'])
                Tempo.append(test_feature[feature]['tempo'])
                
    happycount, sadcount,calmcount,energetic_count = 0,0,0,0
    for i in mood:
        if i == "Happy":
            happycount += 1
        else:
            sadcount += 1
    for i in emotion:
        if i == "Calm":
            calmcount +=1
        else:
            energetic_count +=1
            
    if happycount > sadcount:
        mood_result = "Happy"
        mood_percentage = (happycount * 100)/(happycount + sadcount)
    else:
        mood_result = "Sad"
        mood_percentage = (sadcount * 100) / (happycount + sadcount)
        
    if calmcount > energetic_count:
        emotion_result = "Calm"
        emotion_percentage = (calmcount * 100)/(energetic_count + calmcount)
    else:
        emotion_result = "Energetic"
        emotion_percentage = (energetic_count * 100) / (energetic_count + calmcount)    
    data = {
        'Song Name': songs,
        'Artist': artists,
        'Length': Length,
        'Popularity': popularity,
        'Danceability':Danceability,
        'Acousticness':Acousticness,
        'Energy':Energy,
        'Instrumentalness':Instrumentalness,
        'Liveness':Liveness,
        'Valence':Valence,
        'Loudness':Loudness,
        'Speechiness':Speechiness,
        'Tempo':Tempo
    }
    
    # Create a DataFrame from the data dictionary
    df = pd.DataFrame(data)